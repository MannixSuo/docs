I"–<h2 id="motivation">Motivation</h2>

<p>Also known as Virtual Constructor, The Factory Method is related to the idea on which libtarirs work; a libraries
work: a library used abstract classes for defining and maintaining relations between objects. One type of
responsibility is creating such objects. The library knows when a object needs to be created,but not know what
kind of object it should be created, but not what kind of object it should create, this being specific to the
application using the library.</p>

<p>The Factory method works just the same way: it defindes an interface for creating an object, but leaves the choice of its type to the subclasses,ceration being deferred at run-time. A simple real life example of the
Factory Method is the hotel. When staying in a hotel you first have to check in. The person working at the front desk will give you a key to your room after youâ€™ve paid for the room you want and this way he can be looked as a room factory.</p>

<h2 id="intent">Intent</h2>

<ul>
  <li>
    <p>Defines an interface for creating objects, but let subclasses to decide which class to instantiate</p>
  </li>
  <li>
    <p>Refers to the newly created object through a common interface.</p>
  </li>
</ul>

<h2 id="implementation">Implementation</h2>

<p>The pattern basically works as shown below, in the UML diagram:</p>

<p><img src="/pictures/pattern/factory method implementation - uml class diagram.gif" alt="factory method implementation" /></p>

<p>The participants classes in this pattern are:</p>

<ul>
  <li>
    <p>Product defines the interface for objects the factory method creates.</p>
  </li>
  <li>
    <p>ConcreteProduct implements the Product interface.</p>
  </li>
  <li>
    <p>Creator (also refered as Factory because it creates the Product objects) declares the method FactoryMethod,
which returns a Product object. May call the generating method for creating Product objects.</p>
  </li>
  <li>
    <p>ConcreteCreator overrides the generating method for creating ConcreteProdcut objects</p>
  </li>
</ul>

<p>All concrete products are subclasses of the Product class, so all of them have the same basic implementation,
at some extent. The Creator class specifies all standard and generic behavior of the products and when a new
product is needed, it sends the creation details that are supplied by the client to the ConcreteCreator. Having
this diagram in mind, it is easy for us now to product the code related to it. Here is how the implementation of
the classic Factory method should look:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Product</span> <span class="o">{}</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Creator</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">anOperation</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">factoryMethod</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="nc">Product</span> <span class="nf">factoryMethod</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcreteProduct</span> <span class="kd">implements</span> <span class="nc">Product</span> <span class="o">{}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcreteCreator</span> <span class="kd">extends</span> <span class="nc">Creator</span>
<span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">Product</span> <span class="nf">factoryMethod</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ConcreteProduct</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span> <span class="nc">String</span> <span class="n">arg</span><span class="o">[]</span> <span class="o">)</span> 
    <span class="o">{</span>
        <span class="nc">Creator</span> <span class="n">creator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConcreteCreator</span><span class="o">();</span>
        <span class="n">creator</span><span class="o">.</span><span class="na">anOperation</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h2 id="applicability--examples">Applicability &amp; Examples</h2>

<p>The need for implementing the Factory Method is very frequent. The cases are the ones below:</p>

<ul>
  <li>
    <p>when a class canâ€™t anticipate(é¢„æ–™) the type of the object it is supposed to create</p>
  </li>
  <li>
    <p>When a class wants its subclasses to be the ones to specific the type of a newly created object.</p>
  </li>
</ul>

<h2 id="drawbacks-and-benefits">Drawbacks and Benefits</h2>

<p>Here are the benefits and drawbacks of factory pattern:</p>

<ul>
  <li>
    <p>The main reason for which the factory pattern is used is that it introduces a separation between the application and a family of classes(it introduces weak coupling instead of tight coupling hiding concrete classes from the application). It provides a simple way of extending the family of products with minor changes in application code.</p>
  </li>
  <li>
    <p>It provides customiztion hooks. When the objects are created directly inside the class itâ€™s hard to replace them by objects which extend their functionality. If a factory is used instead to create a family of objects the customized objects can easily repalce the original objects, configuring the factory to create them.</p>
  </li>
  <li>
    <p>The factory has to be used for a family of objects. If the classes doesnâ€™t extend common base class or interface they can not be used in a factory design template.</p>
  </li>
</ul>

<h2 id="hot-points">Hot points</h2>

<p>The factory method is one of the most used and one of the more robust design patterns. There are only few points which have to be considered when you implement a factory method.</p>

<p>When you design an application just think if you really need it a factory to create objects. Maybe using it will bring unnecessary complexity in your application. Anyway if you have many object of the same base type and you manipulate them mostly as abstract objects, then you need a factory. If your have a lot of code like the following, reconsider it.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">if</span> <span class="o">(</span><span class="n">genericProduct</span> <span class="n">typeof</span> <span class="nc">ConcreteProduct</span><span class="o">)</span>
    <span class="o">((</span><span class="nc">ConcreteProduct</span><span class="o">)</span><span class="n">genericProduct</span><span class="o">).</span><span class="na">doSomeConcreteOperation</span><span class="o">();</span>

</code></pre></div></div>
:ET