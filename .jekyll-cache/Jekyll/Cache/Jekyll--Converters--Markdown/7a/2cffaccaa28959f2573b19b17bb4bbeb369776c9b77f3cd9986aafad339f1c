I"}R<p>用法：</p>

<p><code class="language-plaintext highlighter-rouge">docker build</code> 命令会根据Dockerfile和<strong>context</strong>来生成镜像。</p>

<p><strong>context</strong>就是在<code class="language-plaintext highlighter-rouge">PATH</code>或者<code class="language-plaintext highlighter-rouge">URL</code>位置指定的文件。其中<code class="language-plaintext highlighter-rouge">PATH</code>是本地文件夹，<code class="language-plaintext highlighter-rouge">URL</code>是一个远程仓库。</p>

<p>对<strong>context</strong>的处理时递归处理，所以所有的子文件夹都会包括在内。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># . 代表当前文件夹，下面这个命令吧当前文件夹下的东西都打到镜像中了</span>

docker build <span class="nb">.</span>
Sending build context to Docker daemon  6.51 MB

</code></pre></div></div>

<p>Dockerfile这个文件一般在<strong>context</strong>的根目录下，也可以通过<code class="language-plaintext highlighter-rouge">-f</code>参数来指定Dockerfile的位置。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
docker build <span class="nt">-f</span> /path/to/a/Dockerfile <span class="nb">.</span>

</code></pre></div></div>

<p>可以通过<code class="language-plaintext highlighter-rouge">-t</code>命令指定镜像的仓库以及标签</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
docker build <span class="nt">-t</span> shykes/myapp <span class="nb">.</span>

</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">-t</code>参数可以指定多个</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
docker build <span class="nt">-t</span> shykes/myapp:1.0.2 <span class="nt">-t</span> shykes/myapp:latest <span class="nb">.</span>

</code></pre></div></div>

<p>在Docker daemon执行Dockerfile前，会对Dockerfile进行语法检查，错误的语法会报错。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
docker build <span class="nt">-t</span> <span class="nb">test</span>/myapp <span class="nb">.</span>

Sending build context to Docker daemon 2.048 kB
Error response from daemon: Unknown instruction: RUNCMD

</code></pre></div></div>

<p>Docker daemon 一个一个执行Dockerfile中的指令，在最终的镜像id产生之前，会将每个指令的执行结果提交到一个新的镜像中。 Docker daemon会自动清理接收到的<strong>context</strong>。
需要注意：每一条指令都是独立执行的，而且会会生成一个新的镜像，所以指令<code class="language-plaintext highlighter-rouge">RUN cd /tmp</code>不会影响到它的下个指令。</p>

<p>如果可能的话，docker 会重用中间镜像（cache）来加速构建过程。如果使用了cache的话，输出文本中会显示<code class="language-plaintext highlighter-rouge">Using cache</code></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nv">$ </span>docker build <span class="nt">-t</span> svendowideit/ambassador <span class="nb">.</span>

Sending build context to Docker daemon 15.36 kB
Step 1/4 : FROM alpine:3.2
 <span class="nt">---</span><span class="o">&gt;</span> 31f630c65071
Step 2/4 : MAINTAINER SvenDowideit@home.org.au
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 2a1c91448f5f
Step 3/4 : RUN apk update <span class="o">&amp;&amp;</span>      apk add socat <span class="o">&amp;&amp;</span>        <span class="nb">rm</span> <span class="nt">-r</span> /var/cache/
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 21ed6e7fbb73
Step 4/4 : CMD <span class="nb">env</span> | <span class="nb">grep </span><span class="nv">_TCP</span><span class="o">=</span> | <span class="o">(</span><span class="nb">sed</span> <span class="s1">'s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/'</span> <span class="o">&amp;&amp;</span> <span class="nb">echo wait</span><span class="o">)</span> | sh
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 7ea8aef582cc
Successfully built 7ea8aef582cc

</code></pre></div></div>

<h3 id="format">Format</h3>

<p>Dockerfile指令的格式：</p>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># Comment</span>
INSTRUCTION arguments

</code></pre></div></div>

<p>指令是不区分大小写的，但是一般都用大写，来区分指令和指令的参数</p>

<p>Docker顺序读取Dockerfile中的指令，注意：<em>A Dockerfile must begin with a <code class="language-plaintext highlighter-rouge">FROM</code> instruction.</em> 这里的开始位置不是说Dockerfile的第一行,FROM指令有可能会声明在解析器指令/注释/全局参数下。FROM指令指定了parent image，然后再这个镜像的基础上进行构建。</p>

<p>以<em>#</em>开始的行是注释行，除非这行是有效的解析器指令，在其他地方出现的话就被解析成一个参数：</p>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># Comment</span>
<span class="k">RUN </span><span class="nb">echo</span> <span class="s1">'we are running some # of cool things'</span>

</code></pre></div></div>

<p>Parser directives</p>

<p>解析器参数会影响到它下面的指令的处理过程，不会增加构建镜像的层数，并且在build过程中不会显示。解析器参数是通过特殊的注解来指定的<code class="language-plaintext highlighter-rouge"># directive=value</code>,一旦Dockerfile中有注释，空行，构建指令被处理，解析器参数就不在其作用而是被当做注解处理，所以解析器参数都在Dockerfile的最上方。解析器参数是不区分大小写的，一般情况下都用小写。</p>

<p>当前支持两个解析器参数:syntax,escape</p>

<h3 id="syntax">Syntax</h3>

<p>语法格式:</p>

<p><code class="language-plaintext highlighter-rouge"># syntax=[remote image reference]</code></p>

<p>示例</p>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># syntax=docker/dockerfile</span>
<span class="c"># syntax=docker/dockerfile:1.0</span>
<span class="c"># syntax=docker.io/docker/dockerfile:1</span>
<span class="c"># syntax=docker/dockerfile:1.0.0-experimental</span>
<span class="c"># syntax=example.com/user/repo:tag@sha256:abcdef...</span>

</code></pre></div></div>

<p>此功能只有在启用buildKit时才有效。</p>

<p>Escape</p>

<p>通过escape定义dockerfile中的转义字符</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># escape=\ (backslash)</span>

</code></pre></div></div>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># escape=` (backtick)</span>

</code></pre></div></div>

<p>Environment replacement</p>

<p>通过ENV语句定义的环境变量，可以在其他的dockerfile命令中引用，</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$variable_name


${variable_name}

</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">${variable_name}</code>这种还支持bash修饰符语法</p>

<p><code class="language-plaintext highlighter-rouge">${variable:-word}</code> 如果<code class="language-plaintext highlighter-rouge">variable</code>不存在这个表达式值就是<code class="language-plaintext highlighter-rouge">word</code>.
<code class="language-plaintext highlighter-rouge">${variable:+word}</code>  如果<code class="language-plaintext highlighter-rouge">variable</code>存在,那么这个表达式值就是<code class="language-plaintext highlighter-rouge">word</code>,否则是空字符串.</p>

<p>example：</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">FROM</span><span class="s"> busybox</span>
<span class="k">ENV</span><span class="s"> foo /bar</span>
<span class="k">WORKDIR</span><span class="s"> ${foo}   # WORKDIR /bar</span>
<span class="k">ADD</span><span class="s"> . $foo       # ADD . /bar</span>
<span class="k">COPY</span><span class="s"> \$foo /quux # COPY $foo /quux</span>

</code></pre></div></div>

<h3 id="from">From</h3>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">FROM</span><span class="s"> [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</span>

<span class="k">FROM</span><span class="s"> [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span>

<span class="k">FROM</span><span class="s"> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span>

</code></pre></div></div>

<p>form命令初始化一个新的构建层，并且下面的命令都是在这个基本镜像上面进行操作。</p>

<h3 id="run">RUN</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RUN &lt;command&gt;</code> (shell格式,相当于执行一个shell命令，默认是<code class="language-plaintext highlighter-rouge">/bin/sh -c</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">RUN ["executable", "param1", "param2"]</code> (exec 格式)</li>
</ul>

<p>Run命令会在当前镜像上新建一层然后将执行结果保存在新建的那层上，然后这个命令下面的命令都在新的镜像上操作。</p>

<p>如果一行命令太长可以用反斜杠<code class="language-plaintext highlighter-rouge">\</code>来开启新的一行</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
//shell 形式
<span class="k">RUN </span>/bin/bash <span class="nt">-c</span> <span class="s1">'source $HOME/.bashrc; </span><span class="se">\
</span><span class="s1">echo $HOME'</span>

//exec形式
<span class="k">RUN </span><span class="o">[</span><span class="s2">"/bin/bash"</span>, <span class="s2">"-c"</span>, <span class="s2">"echo hello"</span><span class="o">]</span>

</code></pre></div></div>

<h3 id="cmd">CMD</h3>

<p>用于指定默认的容器主进程的启动命令
每个dockerfile只能有一个CMD命令，存在多个的话只有最后一个会生效。</p>

<p><code class="language-plaintext highlighter-rouge">CMD ["executable","param1","param2"]</code></p>

<p><code class="language-plaintext highlighter-rouge">CMD ["param1","param2"]</code></p>

<p><code class="language-plaintext highlighter-rouge">CMD command param1 param2</code></p>

<h3 id="label">LABEL</h3>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">LABEL</span><span class="s"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span>

</code></pre></div></div>

<p>label为镜像添加元数据</p>

<p>EXPOSE</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">EXPOSE</span><span class="s"> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span>

</code></pre></div></div>

<p>expose 声明了容器需要暴露的端口，声明expose不会主动暴露端口，需要在运行<code class="language-plaintext highlighter-rouge">docker run</code> 命令的时候增加<code class="language-plaintext highlighter-rouge">-p</code> 参数来指定暴露端口。</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">EXPOSE</span><span class="s"> 80/tcp</span>
<span class="k">EXPOSE</span><span class="s"> 80/udp</span>

</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
docker run <span class="nt">-p</span> 80:80/tcp <span class="nt">-p</span> 80:80/udp ...

</code></pre></div></div>

<h3 id="env">ENV</h3>

<p>env命令是用来设置环境变量的，设置好以后其他命令就能获取到环境变量的值。</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ENV</span><span class="s"> &lt;key&gt; &lt;value&gt;</span>
<span class="k">ENV</span><span class="s"> &lt;key&gt;=&lt;value&gt; ...</span>
</code></pre></div></div>

<p>env的声明有两种形式</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ENV</span><span class="s"> myName="John Doe" myDog=Rex\ The\ Dog \</span>
    myCat=fluffy

<span class="k">ENV</span><span class="s"> myName John Doe</span>
<span class="k">ENV</span><span class="s"> myDog Rex The Dog</span>
<span class="k">ENV</span><span class="s"> myCat fluffy</span>
</code></pre></div></div>

<p>在执行docker命令时可对env进行覆盖<code class="language-plaintext highlighter-rouge">docker run --env &lt;key&gt;=&lt;value&gt;</code></p>

<h3 id="add">ADD</h3>

<p>add有两种形式</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ADD</span><span class="s"> [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span>
<span class="c"># 如果有空格用下面这种</span>
<span class="k">ADD</span><span class="s"> [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;",... "&lt;dest&gt;"]</span>
<span class="c">#--chown=&lt;user&gt;:&lt;group&gt;这个命令只有在linux镜像仲裁有用，windows镜像中无作用</span>
</code></pre></div></div>

<p>add的作用是将在<code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>声明的文件目录或者远程文件的url添加到镜像的<code class="language-plaintext highlighter-rouge">&lt;dest&gt;</code>路径下。</p>

<p>可以指定多个<code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>，如果它们是文件或目录，则将其路径解释为相对于构建上下文的路径。</p>

<p>add还支持go的文件路径匹配规则如：</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加一hom开头的文件</span>
<span class="k">ADD</span><span class="s"> hom* /mydir/</span>
<span class="c"># ？代表任意一个字符 如home.txt</span>
<span class="k">ADD</span><span class="s"> hom?.txt /mydir/</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;dst&gt;</code>代表源文件要拷贝到容器中的目标地址，一般是一个绝对路径，或者是相对于WORKDIR的路径。</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 将test.txt添加到&lt;WORKDIR&gt;/relativeDir/ 路径下</span>
<span class="k">ADD</span><span class="s"> test.txt relativeDir/</span>
<span class="c"># 将test.txt添加到/absoluteDir/ 这个绝对路径下</span>
<span class="k">ADD</span><span class="s"> test.txt /absoluteDir/</span>
</code></pre></div></div>

<p>Note:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>必须在<code class="language-plaintext highlighter-rouge">context</code>中</li>
  <li>如果<code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>是url文件，并且<code class="language-plaintext highlighter-rouge">&lt;dest&gt;</code>不以<code class="language-plaintext highlighter-rouge">/</code>结尾，那么文件名叫叫做<code class="language-plaintext highlighter-rouge">&lt;dest&gt;</code></li>
  <li>如果<code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>是url文件，并且<code class="language-plaintext highlighter-rouge">&lt;dest&gt;</code>以<code class="language-plaintext highlighter-rouge">/</code>结尾，那么文件名就根据url来判断，保存成`<dest>/不能识别到文件名的。</dest></li>
  <li>如果<code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>是文件夹，那么文件夹内的所有数据都会被拷贝，文件夹本身不会被拷贝。</li>
  <li>如果<code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>是一个本地压缩文件(identity, gzip, bzip2 or xz)，会被自动解压缩成文件夹，相当于执行了<code class="language-plaintext highlighter-rouge">tar -x</code>,如果文件重名了，会以<code class="language-plaintext highlighter-rouge">2.</code>命名。</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>中的一般文件都会根据文件的元属性处理，如果<code class="language-plaintext highlighter-rouge">&lt;dest&gt;</code>以<code class="language-plaintext highlighter-rouge">/</code>结尾，src中的文件都会被放在<code class="language-plaintext highlighter-rouge">&lt;dest&gt;/base(&lt;src&gt;)</code></li>
  <li>如果指定多个<code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>则<code class="language-plaintext highlighter-rouge">&lt;dest&gt;</code>必须要以<code class="language-plaintext highlighter-rouge">/</code>结尾</li>
  <li>如果<code class="language-plaintext highlighter-rouge">&lt;dest&gt;</code>不以<code class="language-plaintext highlighter-rouge">/</code>结尾就代表dest是个文件，则src中的文件以及内容会写到dest这个文件内</li>
  <li>如果<code class="language-plaintext highlighter-rouge">&lt;dest&gt;</code>不存在，它将与路径中所有缺少的目录一起创建。</li>
</ol>

<h3 id="copy">COPY</h3>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">COPY</span><span class="s"> [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span>
<span class="k">COPY</span><span class="s"> [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;",... "&lt;dest&gt;"]</span>

</code></pre></div></div>

<p>COPY命令将<code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>中的文件添加到容器的<code class="language-plaintext highlighter-rouge">&lt;dest&gt;</code>路径中。</p>

<p>可以指定了多个<code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>，<code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>的路径是相对于当前构建的<code class="language-plaintext highlighter-rouge">context</code>的。</p>

<p>同ADD，<code class="language-plaintext highlighter-rouge">&lt;src&gt;</code>的路径也可以使用go语言的路径匹配机制</p>

<p>copy不能从url下载文件而add可以</p>

<h3 id="entrypoint">ENTRYPOINT</h3>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># exec form</span>
<span class="k">ENTRYPOINT</span><span class="s"> ["executable", "param1", "param2"]</span>
<span class="c"># shell form</span>
<span class="k">ENTRYPOINT</span><span class="s"> command param1 param2</span>

</code></pre></div></div>

<p>ENTRYPOINT 将容器配置成可执行的。</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -i -t --rm -p 80:80 nginx
</code></pre></div></div>

<p>命令 <code class="language-plaintext highlighter-rouge">docker run &lt;image&gt;</code> 的参数会被添加到exec form类型的ENTRYPOINT后面，对于CMD命令中的参数会被覆盖而不是添加到参数后面。
比如： ` docker run <image> -d `会生成` ENTRYPOINT["a","b","-d"] `,会覆盖 ` CMD["a","b"] ` 生成` CMD["-d"] `。</image></p>

<p>ENTRYPOINT执行的命令 PID是1，cmd是<code class="language-plaintext highlighter-rouge">/bin/sh -c</code> 的子命令，pid不是1</p>

<h3 id="arg">ARG</h3>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ARG</span><span class="s"> &lt;name&gt;[=&lt;default value&gt;]</span>
</code></pre></div></div>

<p>ARG 参数定义了一个变量，可以在执行<code class="language-plaintext highlighter-rouge"> docker build </code>命令时通过<code class="language-plaintext highlighter-rouge"> --build-arg &lt;varname&gt;=&lt;value&gt; </code>来指定变量的值。</p>

<p>Arg命令在使用<code class="language-plaintext highlighter-rouge"> docker history </code>查看的时候会显示出来，所以密码什么的不能通过arg传递。</p>
:ET