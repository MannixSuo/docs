I"ý8<h2 id="motivation">Motivation</h2>

<p>Sometimes we need the ability to control the access to an object. For example if we need to use only a few methods of some coostly objects weâ€™ll initialize those objects when we need them entirely. Until that point we can use some light objects exposing the same interface as the heavy objects. These light objects are called proxies and they will instantiate those heavy objects when they are really need and by then weâ€™ll use some light objects instead.</p>

<p>This ability to control the access to an object can be required for a variety of reasons: controling when a costly objects needs to be instantiated and initalized, giving different access rights to an object, as well as providing a sophisticated means of accessing and referencing objects running in other process, on other machines.</p>

<p>Consider for example an image viewer program. An image program must be able to list and display high resolution photo objects that are in folder, but how often do someone open a folder and view all the images inside. Sometimes you will be looking for a particular photo, sometimes you will only want to see  an image name. The image viewer must be able to list all photo obkects, but the photo objects must not be loaded into memory until they are required to be rendered.</p>

<h2 id="intent">Intent</h2>

<p>The intent of this pattern is to provide a <code class="language-plaintext highlighter-rouge">Plactholder</code> for an object to control references to it.</p>

<h2 id="implementation">Implementation</h2>

<p>The figure below shows a UML class diagram for the Proxy Pattern:</p>

<p><img src="/pictures/pattern/proxy-design-pattern-implementation-uml-class-diagram.png" alt="proxy pattern" /></p>

<p>The participants classes in the proxy pattern are:</p>

<ul>
  <li>
    <p><strong>Subject</strong> - interface implemented by the RealSubject and representing its services. The interface must be implemented by the proxy as well so that the proxy can be used in any location where the RealSubject can be used.</p>
  </li>
  <li>
    <p><strong>Proxy</strong></p>
  </li>
  <li>
    <ul>
      <li>Maintains a reference that allows the Proxy to access the RealSubject.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Implements the same interface implented by the RealSubject so that the Proxy can be substitude for the RealSubject.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Controls access to the RealSubject and may be responsible for its creation and deletion</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Other responsibilities depend on the kind of proxy.</li>
    </ul>
  </li>
  <li><strong>RealSubject</strong> - the real object that the proxy represents.</li>
</ul>

<h2 id="description">Description</h2>

<p>A client obtains a reference to a Proxy, the client then handles the proxy in the same way it handles RealSubject and thus invoking the method doSomething(). At that point the proxy can do different things prior to invoking RealSubjectâ€™s doSomething() method. The client might create a RealSubject object at that point, perform initialization, check permissions of the client to invoke the method on the object. The client can also do additional tasks after invoking the doSomething() method, such as incrementing the number of references to the object.</p>

<h2 id="applicability--examples">Applicability &amp; Examples</h2>

<p>The Proxy design pattern is applicable when there is a need to control access to an Object, as well as when there is a need for a sophisticated reference to an object. Common Situations where the proxy pattern is applicable are :</p>

<ul>
  <li>
    <p><strong>Virtual Proxies:</strong> delaying the creation an initialization of expensive objects until needed, where the objects are created on demand (for example creating the RealSubject object only when the doSomething method is invoked).</p>
  </li>
  <li>
    <p><strong>Remote Proxies:</strong> providing a local representation for an object that is in a different address space. A common example is Java RMI stub objects. The stub object acts as a proxy where invoking methods on the stub would cause the stub to communicate and invoke methods on a remote object (called skeleton) found on a different machine.</p>
  </li>
  <li>
    <p><strong>Protection Proxies:</strong> Where a proxy controls access to RealSubject methods, by giving access to some objects while denying access to others.</p>
  </li>
  <li>
    <p><strong>Smart References:</strong> Providing a sophisticated access to certain objects such as tracking the number of reference to an object and denying access if a certaion number is reached, as well as loading an object from database into memory on demand.ss</p>
  </li>
</ul>

<h2 id="example---virtual-proxy-example">Example - Virtual Proxy Example.</h2>

<p>Consider an image viewer program that lists and displays high resolution photos. The program has to show a list of photos however it does not need to display the actual photo until the user selects an image item from a list.</p>

<p><img src="/pictures/pattern/proxy-design-pattern-image-example-uml-class-diagram.png" alt="proxy" /></p>

<p>The code below shows the Image interface representing the Subject. The interface has a single method showImage() that the concrete images must implement it to render an image to screen.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Subject Interface
 */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Image</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">showImage</span><span class="o">();</span>
	
<span class="o">}</span>
</code></pre></div></div>
<p>The code below shows the Proxy implementation, the image proxy is a virtual proxy that creates and loads the actual image object on demand, thus saving the cost of loading an image into memory until it needs to be rendered:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Proxy
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ImageProxy</span> <span class="kd">implements</span> <span class="nc">Image</span> <span class="o">{</span>

	<span class="cm">/**
	 * Private Proxy data 
	 */</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">imageFilePath</span><span class="o">;</span>
	
	<span class="cm">/**
	 * Reference to RealSubject
	 */</span>
	<span class="kd">private</span> <span class="nc">Image</span> <span class="n">proxifiedImage</span><span class="o">;</span>
	
	
	<span class="kd">public</span> <span class="nf">ImageProxy</span><span class="o">(</span><span class="nc">String</span> <span class="n">imageFilePath</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">imageFilePath</span><span class="o">=</span> <span class="n">imageFilePath</span><span class="o">;</span>	
	<span class="o">}</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">showImage</span><span class="o">()</span> <span class="o">{</span>

		<span class="c1">// create the Image Object only when the image is required to be shown</span>
		
		<span class="n">proxifiedImage</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HighResolutionImage</span><span class="o">(</span><span class="n">imageFilePath</span><span class="o">);</span>
		
		<span class="c1">// now call showImage on realSubject</span>
		<span class="n">proxifiedImage</span><span class="o">.</span><span class="na">showImage</span><span class="o">();</span>
		
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>The code below displays the RealSubject Implementation which is the concrete and heavyweight implementation of the image interface. The High resolution image loads a high resolution image from disk, and renders it to screen when showImage() is called:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/**
 * RealSubject
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HighResolutionImage</span> <span class="kd">implements</span> <span class="nc">Image</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="nf">HighResolutionImage</span><span class="o">(</span><span class="nc">String</span> <span class="n">imageFilePath</span><span class="o">)</span> <span class="o">{</span>
		
		<span class="n">loadImage</span><span class="o">(</span><span class="n">imageFilePath</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">loadImage</span><span class="o">(</span><span class="nc">String</span> <span class="n">imageFilePath</span><span class="o">)</span> <span class="o">{</span>

		<span class="c1">// load Image from disk into memory</span>
		<span class="c1">// this is heavy and costly operation</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">showImage</span><span class="o">()</span> <span class="o">{</span>

		<span class="c1">// Actual Image rendering logic</span>

	<span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>

<p>The code below illustrates a asmple image viewer program; the program simply loads three images, and renders only one image, once using the proxy pattern and another use directly. Note that when using the proxy pattern, although three images have been loaded, the high resolution image is not loaded into memory until it needs to be rendered, while in the part not using the proxy,three images are loaded into memory alough only one of them is actually rendered.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">proxy</span><span class="o">;</span>

<span class="cm">/**
 * Image Viewer program
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ImageViewer</span> <span class="o">{</span>

	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		
	<span class="c1">// assuming that the user selects a folder that has 3 images	</span>
	<span class="c1">//create the 3 images 	</span>
	<span class="nc">Image</span> <span class="n">highResolutionImage1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ImageProxy</span><span class="o">(</span><span class="s">"sample/veryHighResPhoto1.jpeg"</span><span class="o">);</span>
	<span class="nc">Image</span> <span class="n">highResolutionImage2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ImageProxy</span><span class="o">(</span><span class="s">"sample/veryHighResPhoto2.jpeg"</span><span class="o">);</span>
	<span class="nc">Image</span> <span class="n">highResolutionImage3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ImageProxy</span><span class="o">(</span><span class="s">"sample/veryHighResPhoto3.jpeg"</span><span class="o">);</span>
	
	<span class="c1">// assume that the user clicks on Image one item in a list</span>
	<span class="c1">// this would cause the program to call showImage() for that image only</span>
	<span class="c1">// note that in this case only image one was loaded into memory</span>
	<span class="n">highResolutionImage1</span><span class="o">.</span><span class="na">showImage</span><span class="o">();</span>
	
	<span class="c1">// consider using the high resolution image object directly</span>
	<span class="nc">Image</span> <span class="n">highResolutionImageNoProxy1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HighResolutionImage</span><span class="o">(</span><span class="s">"sample/veryHighResPhoto1.jpeg"</span><span class="o">);</span>
	<span class="nc">Image</span> <span class="n">highResolutionImageNoProxy2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HighResolutionImage</span><span class="o">(</span><span class="s">"sample/veryHighResPhoto2.jpeg"</span><span class="o">);</span>
	<span class="nc">Image</span> <span class="n">highResolutionImageBoProxy3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HighResolutionImage</span><span class="o">(</span><span class="s">"sample/veryHighResPhoto3.jpeg"</span><span class="o">);</span>
	
	
	<span class="c1">// assume that the user selects image two item from images list</span>
	<span class="n">highResolutionImageNoProxy2</span><span class="o">.</span><span class="na">showImage</span><span class="o">();</span>
	
	<span class="c1">// note that in this case all images have been loaded into memory </span>
	<span class="c1">// and not all have been actually displayed</span>
	<span class="c1">// this is a waste of memory resources</span>
	
	<span class="o">}</span>
		
<span class="o">}</span>
</code></pre></div></div>

<h2 id="specific-problems-and-implementation">Specific problems and implementation</h2>

<h3 id="java-remote-method-invocation-rmi">Java Remote Method Invocation (RMI)</h3>

<p>In Java RMI an object on one machine (executing in one JVM) called a client can invoke methods on am object in another machine (another JVM) the second object is called a remote object. The proxy (also called a stub) residers on the client machine and the client invokes the proxy in as if it is invoking the object itself (remember that the proxy implements the same interface that RealSubject implements). The proxy itself will handle communication to the remote object, invoke the method on that remote object, and would return the result if any to the client. The proxy in this case is a Remote proxy.s</p>

<h2 id="related-patterns">Related Patterns</h2>

<p><strong>Decorator Design Pattern</strong> - A decorator implementation can be the same as the proxy, however a decorator adds reponsibilities to an object while a proxy controls access to it.</p>
:ET