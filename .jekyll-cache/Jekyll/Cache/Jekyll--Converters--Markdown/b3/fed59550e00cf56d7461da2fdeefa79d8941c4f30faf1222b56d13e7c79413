I"‚9<h2 id="motivation">Motivation</h2>

<p>Sometimes itâ€™s important to have only one instance for a class. For example,
in a system there should be only one window manager(or only a file system).
Usually singletons are used for centralized management of internal or external resources and they provide a global point of access to themselves.</p>

<p>The singleton pattern is one of the simplest design patterns: it involves only one class which is responsible to instantiate itself, to make sure it
creates not more than one instances; in the same time it provides a global
point of access to that instance. In this case the same instance can be used
from everywhere, being impossible to invoke the constructor directly each
time.</p>

<h2 id="intent">Intent</h2>

<ul>
  <li>Ensure that only one instance of a class is created.</li>
  <li>Provide a global point of access to the object.</li>
</ul>

<h2 id="implementation">Implementation</h2>

<p>The implementation involves a static member in the â€˜Singletonâ€™ class, a private constructor and a static public method that returns a reference to
the static member.</p>

<p><img src="/pictures/pattern/singleton_implementation_-_uml_class_diagram.gif" alt="singleton_implementation" /></p>

<p>The Singleton Pattern defines a getInstance operation which exposes the unique instance which is accessed by the clients. <em>getInstance()</em> is responsible for creating its class in case it is not created yet and return that instance.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="n">instance</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">(){</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>

        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
   <span class="o">...</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>You can notice in the above code that <em>genInstance</em> method ensures that only one instance of the class is created. The constructor should not be accessible fron the outside of the class to ensure the only way of instantiating the class would be only through the <em>getInstance</em> method.</p>

<p>The getInstance method is used also to provide a global point of access to the object and it can be use in the following manner:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">doSomething</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="applicability--examples">Applicability &amp; Examples</h2>

<p>According to the definition the singleton pattern should be used when there must be exactly one instance of a class, and it must be accessible to clients from a global access point. Here are some real situations where the
singleton is used.</p>

<h3 id="example-1---logger-classes">Example 1 - Logger Classes</h3>

<p>The singleton pattern is used in the design fo logger classes. This classes are usually  implemented as a singleton, and provides a global logging access point in all the application components without being necessary to create an object each time a logging operations is performed.</p>

<h3 id="example-2---configuration-classes">Example 2 - Configuration Classes</h3>

<p>The singleton pattern is used to design the classes which provieds the configuration settings for an application. By implementing configuration classes as singleton not only that we provide a global access point, but
we also keep the instance we used a cache object. When the class is instantiated(or when a value is read) the singleton will keep the values in its internal structure. If the values are read from the database or from files this avoid to realoading the values each time the configuration parameters are used.</p>

<h2 id="specific-problems-and-implementation">Specific problems and implementation</h2>

<h3 id="thread---safe-implementation-for-multi-threading-use">Thread - safe implementation for multi-threading use.</h3>

<p>A robust singleton implementation should work in any conditions. This is why we need to ensure it works correctly when multiple threads uses it. As seen in the previous examples singleton can be used specifically in multi-thread application to make sure the read/write are synchronized.</p>

<p>Lazy instantiation using double locking mechanism.</p>

<p>The standard implementation shown in the above code is a thread safe implementation, but itâ€™s not the best thread-safe implementation because synchronization is very expensive when we are talking about the performance.
We can see that the synchronized method <em>getInstance</em> does not need to be checked for synchronization after the object is initialized. If we see that
the singleton object is already created we just return it. This optimization consist inchecking in an unsynchronized block if the object is null and if not to check again and create it in an synchronized block. This is called double locking mechanism.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Lazy instantiation using double locking mechanism.</span>
<span class="kd">class</span> <span class="nc">Singleton</span>
<span class="o">{</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="n">instance</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span>
	<span class="o">{</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Singleton(): Initializing Instance"</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span>
	<span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
		<span class="o">{</span>
			<span class="kd">synchronized</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
			<span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
				<span class="o">{</span>
					<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"getInstance(): First time getInstance was invoked!"</span><span class="o">);</span>
					<span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
				<span class="o">}</span>
			<span class="o">}</span>            
		<span class="o">}</span>

		<span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span>
	<span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"doSomething(): Singleton does something!"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Early instantiation use implementation with static field</p>

<p>In the following implementation the singleton object is instantited when the class is loaded and not when it is first used, due to the fact that the instance menber is declared static. This is why we doâ€™t need to synchronize any portion of the code in this case. The class is loaded once this guarantee the uniquity of the object.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Lazy instantiation using double locking mechanism.</span>
<span class="kd">class</span> <span class="nc">Singleton</span>
<span class="o">{</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="n">instance</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span>
	<span class="o">{</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Singleton(): Initializing Instance"</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span>
	<span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
		<span class="o">{</span>
			<span class="kd">synchronized</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
			<span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
				<span class="o">{</span>
					<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"getInstance(): First time getInstance was invoked!"</span><span class="o">);</span>
					<span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
				<span class="o">}</span>
			<span class="o">}</span>            
		<span class="o">}</span>

		<span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span>
	<span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"doSomething(): Singleton does something!"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="multiple-singleton-instances-if-classess-loaded-by-different-classloaders">Multiple singleton instances if classess loaded by different classloaders.</h2>

<p>If a class(same name, same package) is loaded by 2 different classloaders they represent 2 differnt classes in memory.</p>

<h2 id="serialization">Serialization</h2>

<p>In java, if a singleton class implements the java.io.Serializable interface,then the singleton is serialized and can be deserialized more than once, there will be multiple instances of singleton class created. In order to avoid this the readResolve method should be implemented.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
	<span class="o">...</span>

	<span class="c1">// This method is called immediately after an object of this class is deserialized.</span>
	<span class="c1">// This method returns the singleton instance.</span>
	<span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="nf">getInstance</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="abstract-factory-and-factory-method-implemented-as-singletons">Abstract Factory and Factory Method implemented as singletons</h2>

<p>There are certain situations when the factory should be unique. Haveing 2 factories might have undesired effects when objects are created. To ensure that a factory is unique it should be implemented as a singleton. By doing so we also avoid to instantiate the class before using it.</p>

<h2 id="hot-spot">Hot Spot</h2>

<ul>
  <li><strong>Multithreading</strong> - A special care should be taken when singleton has to be used in a multithreading application.</li>
  <li><strong>Serialization</strong> - when singletons are implementing serializable interface they have to implement readResolve method in order to avoid having 2 different objects.</li>
  <li><strong>Classloaders</strong> - If the singleton class is loaded by 2 different classloaders weâ€™ll have 2 different classes, one for each classloader.</li>
  <li><strong>Global Access Point represented by the class name</strong> - The singleton instance is obtained using the class name. At the first view this is an easy way access it, but it is not very flexible. If we need to replace the singleton class, all the reference in the code should be changed accordinglly.</li>
</ul>

:ET