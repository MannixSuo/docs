I" '<h2 id="removeelemets">removeElemets</h2>

<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>

<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>

<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>

<p>解法1：</p>

<p>两个动点currentIndex ,nextIndex 其中nextIndex依次往后遍历，判断位于nextIndex的元素是否和val相等，如果相等nextIndex++在判断，如果不相等将该元素放到currentIndex的位置然后currentIndex++，nextIndex++</p>

<p><code class="language-plaintext highlighter-rouge">_____currentIndex&gt;__________nextIndex&gt;________</code></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">removeElement</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">currentIndex</span><span class="p">,</span> <span class="n">nextIndex</span> <span class="kt">int</span>
    <span class="n">currentIndex</span> <span class="o">=</span> <span class="m">0</span>
    <span class="k">for</span> <span class="n">nextIndex</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">nextIndex</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span> <span class="n">nextIndex</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">nextIndex</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">nextIndex</span><span class="p">]</span>
        <span class="n">currentIndex</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">currentIndex</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="strstr">strStr</h2>

<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>

<p>解法1:</p>

<p>遍历haystack中的每个字符，如果和needle的第一个相等，在判断下一个，如果不相等haystackIndex++</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">func</span> <span class="n">strStr</span><span class="p">(</span><span class="n">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="n">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">needle</span> <span class="o">==</span> <span class="s">""</span> <span class="p">{</span>
        <span class="k">return</span> <span class="m">0</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="n">haystackIndex</span><span class="p">,</span> <span class="n">needleIndex</span><span class="p">,</span> <span class="n">haystackIndexCopy</span> <span class="kt">int</span>
    <span class="k">for</span> <span class="n">haystackIndex</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">haystackIndex</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">);</span> <span class="n">haystackIndex</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">haystackIndexCopy</span> <span class="o">=</span> <span class="n">haystackIndex</span>
        <span class="k">for</span> <span class="n">needleIndex</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">needleIndex</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">haystackIndexCopy</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">);</span> <span class="n">needleIndex</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">haystackIndexCopy</span><span class="p">]</span> <span class="o">!=</span> <span class="n">needle</span><span class="p">[</span><span class="n">needleIndex</span><span class="p">]</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="n">haystackIndexCopy</span><span class="o">++</span>
            <span class="k">if</span> <span class="n">needleIndex</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">)</span><span class="o">-</span><span class="m">1</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">haystackIndex</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span>
</code></pre></div></div>

<p>解法2：</p>

<p>字符串前后两端都进行判断。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">strStr</span><span class="p">(</span><span class="n">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="n">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">needle</span> <span class="o">==</span> <span class="s">""</span> <span class="p">{</span>
        <span class="k">return</span> <span class="m">0</span>
    <span class="p">}</span>
    <span class="n">haystackLen</span><span class="p">,</span> <span class="n">needleLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">)</span>
    <span class="k">var</span> <span class="n">haystackIndex</span><span class="p">,</span> <span class="n">needleIndex</span><span class="p">,</span> <span class="n">haystackIndexCopy</span><span class="p">,</span> <span class="n">needleLenCopy</span> <span class="kt">int</span>
    <span class="k">for</span> <span class="n">haystackIndex</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">haystackIndex</span> <span class="o">&lt;=</span> <span class="n">haystackLen</span><span class="o">-</span><span class="n">needleLen</span><span class="p">;</span> <span class="n">haystackIndex</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">haystackIndexCopy</span> <span class="o">=</span> <span class="n">haystackIndex</span>
        <span class="n">needleLenCopy</span> <span class="o">=</span> <span class="n">needleLen</span> <span class="o">-</span> <span class="m">1</span>
        <span class="k">for</span> <span class="n">needleIndex</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">needleIndex</span> <span class="o">&lt;</span> <span class="n">needleLen</span> <span class="o">&amp;&amp;</span> <span class="n">haystackIndexCopy</span> <span class="o">&lt;</span> <span class="n">haystackLen</span><span class="p">;</span> <span class="n">needleIndex</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">haystackIndexCopy</span><span class="p">]</span> <span class="o">!=</span> <span class="n">needle</span><span class="p">[</span><span class="n">needleIndex</span><span class="p">]</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">haystackIndexCopy</span><span class="o">+</span><span class="n">needleLenCopy</span><span class="p">]</span> <span class="o">!=</span> <span class="n">needle</span><span class="p">[</span><span class="n">needleLenCopy</span><span class="p">]</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="n">haystackIndexCopy</span><span class="o">++</span>
            <span class="n">needleLenCopy</span><span class="o">--</span>
            <span class="k">if</span> <span class="n">haystackIndexCopy</span> <span class="o">&gt;</span> <span class="n">needleLenCopy</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">haystackIndex</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span>
</code></pre></div></div>
:ET