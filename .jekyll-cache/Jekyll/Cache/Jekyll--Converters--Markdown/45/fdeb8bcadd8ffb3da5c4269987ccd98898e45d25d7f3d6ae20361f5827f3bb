I"><h2 id="motivation">Motivation</h2>

<p>If we take a look at the dictionary definition of a template we can see that a template is apresent format,used as a staring point for a particular application so that the format does not have to recreated each time it is used.</p>

<p>On the same idea is the template method is based. A template method defines an algorithm in a base class using abstract operations that subclasses override to provide concrete behavior.</p>

<h2 id="intent">Intent</h2>

<ul>
  <li>
    <p>Define the seleton(骨架) of an algorithm in an operation, deferring some steps to subclasses.</p>
  </li>
  <li>
    <p>Template Method lets subclasses redefine certain steps of an algorithm without letting them to change the algorithm’s structure.</p>
  </li>
</ul>

<p><img src="/pictures/pattern/template_method_implementation_-_uml_class_diagram.gif" alt="template method" /></p>

<h2 id="implementation">Implementation</h2>

<ol>
  <li>
    <p><strong>AbstractClass</strong></p>

    <ol>
      <li>
        <p>Define abstract primitive operations that concrete subclasses define to implement step of an algorithm.</p>
      </li>
      <li>
        <p>Implements a template method which defines the skeleton of an algorithm. The template method calls primitive operations as well as operations defined in AbstraceClass or those of other objects.</p>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>ConcreteClass</strong></p>

    <ol>
      <li>Implements the primitive operations to carry out subclass-specific steps of an algorithm. When a concrete class is called the template method code will be executed from the base class while for each method use inside the template method will be called the implementation from the derived class.</li>
    </ol>
  </li>
</ol>

<h2 id="applicability--examples">Applicability &amp; Examples</h2>

<p>The tempalte Method pattern should be used:</p>

<ol>
  <li>
    <p>To implement the invariant parts of an algorithm once and leave it up to subclasses to implement the behavior that can vary.</p>
  </li>
  <li>
    <p>When refactoring is performed and common behavior is identified among classes. A abstract base class containing all the common code(in the template method) should be created to avoid code duplication.</p>
  </li>
</ol>

<h2 id="example---application-used-by-a-travel-agency">Example - Application used by a travel agency.</h2>

<p><img src="/pictures/pattern/template_method_example_trips_-_uml_class_diagram.gif" alt="travel agency" /></p>

<p>Let’s assume we have to develop an application for a travel agency. The travel agency is managing each trip. All the trips contain common behavior but there are serveral packages. For example each trip contains the basic steps:</p>

<ul>
  <li>
    <p>The toutist are transported to the holiday location by plane/train/ships…</p>
  </li>
  <li>
    <p>Each day they are visiting something</p>
  </li>
  <li>
    <p>They are returning back home.</p>
  </li>
</ul>

<p>So we create an abstract class containing each step as an abstract method and one concrete final method that calls all the abstract methods. Then we create one superclass for each package:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Trip</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">performTrip</span><span class="o">(){</span>
                 <span class="n">doComingTransport</span><span class="o">();</span>
                 <span class="n">doDayA</span><span class="o">();</span>
                 <span class="n">doDayB</span><span class="o">();</span>
                 <span class="n">doDayC</span><span class="o">();</span>
                 <span class="n">doReturningTransport</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">doComingTransport</span><span class="o">();</span>
        <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">doDayA</span><span class="o">();</span>
        <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">doDayB</span><span class="o">();</span>
        <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">doDayC</span><span class="o">();</span>
        <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">doReturningTransport</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PackageA</span> <span class="kd">extends</span> <span class="nc">Trip</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doComingTransport</span><span class="o">()</span> <span class="o">{</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The turists are comming by air ..."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doDayA</span><span class="o">()</span> <span class="o">{</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The turists are visiting the aquarium ..."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doDayB</span><span class="o">()</span> <span class="o">{</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The turists are going to the beach ..."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doDayC</span><span class="o">()</span> <span class="o">{</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The turists are going to mountains ..."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doReturningTransport</span><span class="o">()</span> <span class="o">{</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The turists are going home by air ..."</span><span class="o">);</span>
        <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PackageB</span> <span class="kd">extends</span> <span class="nc">Trip</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doComingTransport</span><span class="o">()</span> <span class="o">{</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The turists are comming by train ..."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doDayA</span><span class="o">()</span> <span class="o">{</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The turists are visiting the mountain ..."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doDayB</span><span class="o">()</span> <span class="o">{</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The turists are going to the beach ..."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doDayC</span><span class="o">()</span> <span class="o">{</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The turists are going to zoo ..."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doReturningTransport</span><span class="o">()</span> <span class="o">{</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The turists are going home by train ..."</span><span class="o">);</span>
        <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="specific-problems-and-implementation">Specific problems and implementation</h2>

<h3 id="concrete-base-class">Concrete base class</h3>

<p>It is not necessary to have the superclass as an abstract class. It can be a concrete class containing a method(template method) and some default functionality. In this case the primitive methods can not be abstract and this is a flaw because it is not so clear which methods have to be override and which not. A concrete base class should be used only when customizations hooks are implemented.</p>

<h3 id="template-method-can-not-be-override">Template method can not be override</h3>

<p>The template method implemented by the base class should not be overriden. The specific programing language modifiers should be used to ensure this.</p>

<h3 id="customization-hooks">Customization Hooks</h3>

<p>A particular case of the template method pattern is represented by the hooks. The hooks are generally empty method that are called in superclass(and does nothing because are empty), but can be implemented in subclasses. Customization Hooks can be considered a particular case of the template method as well as a totally different mechanism. Usually a subclass can have a method extended by overriding and calling the parent method explicitly:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Subclass</span> <span class="kd">extends</span> <span class="nc">Superclass</span>
<span class="o">{</span>
    <span class="o">...</span>
    <span class="kt">void</span> <span class="nf">something</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// some customization code to extend functionality</span>
    <span class="kd">super</span><span class="o">.</span> <span class="nf">something</span> <span class="o">();</span>
    <span class="c1">// some customization code to extend functionality</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Unfortunately it is easy to forget to call the super and this is forcing the developer to check the existing code from the method in Superclass.</p>

<p>Instead of overriding some hook methods can be added. Then in the subclasses only the hooks should be implemented without being aware of the method something:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Superclass</span>
<span class="o">{</span>
    <span class="o">...</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">preSomethingHook</span><span class="o">(){}</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">postSomethingHook</span><span class="o">(){}</span>
    <span class="kt">void</span> <span class="nf">something</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">preSomethingHook</span><span class="o">();</span>
        <span class="c1">// something implementation</span>
        <span class="n">postSomethingHook</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Subclass</span> <span class="kd">extends</span> <span class="nc">Superclass</span>
<span class="o">{</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">preSomethingHook</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="c1">// customization code</span>
    <span class="o">}</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">postSomethingHook</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="c1">// customization code</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="minimizing-primitive-methods-number">Minimizing primitive methods number</h3>

<p>It’s important to identify the primitive methods is it better to use a specific naming convention. For example the prefix “do” can be used for primitive methods. In a similar way the customizations hooks can have prefixes like “pre” and “post”.</p>

<h3 id="when-methods-taht-should-be-abstract-or-not">When methods taht should be abstract or not</h3>

<p>When there is a method in the base class that should contain some default code, but on the other side it’s necessary to be extended in the subclasses it should be split in 2 methods: one abstract and one concrete. We can not rely in the fact that the subclasses will override the method and will call the super implementation in it like this :</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">something</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span> <span class="nf">something</span> <span class="o">();</span>
    <span class="c1">// extending the method</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="template-method-and-strategy-pattern">Template Method and Strategy Pattern</h3>

<p>The Strategy Pattern is with Template Method Pattern. The difference consists in the fact that Strategy uses delegation while the Template Methods uses the inheritance.</p>

<h2 id="hot-points">Hot Points</h2>

<p>Template method is using as an inverted controls structure, sometimes referred as “the Hollywood principle”: from the superclass point of view: “Don’t call us, we’ll call you”. This refers to the fact that instead of calling the methods from base class, the methods from subclass are called in the template method from superclass.
Due to the above fact a special care should be paid to access modifiers: the template method should be implemented only in the base class, and the primitive method should be implemented in the subclasses. A particular case of the template method is represented by the customization hooks.</p>
:ET