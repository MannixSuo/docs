---
title: 数组和指针
layout: posts
tags: C语音
---

```C

    // 数组初始化

    int powers[8] = {1,2,4,,6,8,16,32,64};
    sizeof(powers);
    //数组的大小，以字节为单位
    sizeof(powers)/sizeof(powers[0]);
    //数组内元素的个数
    //如果省略方括号中的数字，编译器会根据列表中的项数确定数组大小。

    // 未初始化的数组里面的元素是内存相应位置上现有的值。

    // 如果初始化数组内的部分元素剩余的元素就会被初始化为0；

    // C99新增指定初始化器

    int arr[6] = {[5]=212};
    // 第5个元素初始化为212 其他的为0
    // 如果指定初始化器后面有更多的值，那个后面的值会被用于指定初始化指定元素后面的元素
    int stuff[] = {1,[6]=4,9,10};
    // 最终会有9个元素0-8

    // C不允许把一个数组赋值给另一个数组。
    // 也不允许花括号形式的赋值。

    float rain[5][12];
    // 内含5个数组元素的数组，每个数组元素内含有12个float类型的值
    short data[10];
    short * pti;
    pti = data; //把数组地址赋值给指针
    pti +1;
    // 在c语言中指针加一指的是增加一个存储单元，加一后意味着地址是下个元素的地址不是下一个字节的地址。这就是为什么需要声明指针所指向对象类型的原因
    pti+2==&data[2];// 相同的地址
    *(pti+2)==data[2];//相同的值

    // 以数组为参数的函数原型：
    int sum(int * ar); or int sum(int ar[]);
    // 只有在函数原型或者函数定义头中才能使用`int ar[]`代替`int *ar`
    // `int ar[]`只能用于声明形式参数。`(int ar[])` 提醒读者指针ar指向的不仅仅是一个int类型的值，还是int类型的数组的元素

    // 数组名是数组首元素的地址。

    // 指针变量也有自己的地址和值，他的值就是所它所指向的地址。

    // 指针求差求出两个元素之间的距离。

    // ### 千万不要解引用未初始化的指针 ###

    // 为了防止函数修改数组中的值，在形式参数前加const可防止数组的值被函数修改

    int sum(const int arr[],int len);

    // 指向const的指针不能用于修改值

    double arr[] = {1.1,2.2,3.3,4.4,5.5,6.6};
    const double carr[] = {1.1,2.2,3.3,4.4,5.5,6.6};
    const double * pt = arr;
    double * ptr;
    *pt = 6.6; // 不允许 因为pt指针声明为const表明该指针不能用来修改它所指向的值
    pt++;// 允许 可以让pt指向别处
    ptr = carr;//不允许 const变量不能赋值给非const指针

    double * const pc = arr;// 该指针不能指向别处 只能指向初始化时的地址。
    const double * const ccpc;//该指针不能指向别处也不能修改其指向的值

    // 变长数组

    int quarters = 4;
    int regions = 5;
    double sales[regions][quarters];//一个变长数组，变长数组一旦创建，其长度也不能改变，变长指的是初始化时的长度可以根据变量确定
    int sum2d(int rows,int cols,int ar[rows][cols]);//变长数组为参数的函数必须在声明数组前声明数组大小的参数
    int sum2d(int ,int ,int ar[*][*]);

    // 复合字面量

    (int [2]){10,20};//复合字面量,相当于一个匿名内部类，不能在创建完成后使用，只能在创建的时候使用。

    //编译器会把数组表示法转换成指针表示法，比如ar[1]会被转换成ar+1，编译器对ar+1求值就要知道ar所指向对象的大小。
    //因此函数在接收多维数组为参数时，

    int sum2(int ar[][],int rows);// 错误
    int sum2(int ar[][4],int rows);//正确

    int (*ptr)[2];//声明一个二维数组的指针，其中列的大小为2。

    // 如果第二个括号里是空的，编译器就不知道所指向对象的大小。

    // ### 复习题 ###

    // 1. 下面的层序将打印什么内容？

    //     8 8
    //     4 4
    //     0 0
    //     2 2

    // 2. 在1中ref有多少个元素？

    //     4

    // 3. 在1中ref的地址是什么？ref+1是什么意思？++ref指向什么？

    //     ref的地址是&ref[0],ref+1是&ref[1],++ref不是一个表达式因为ref是一个常量不是变量。

    // 4. 在下面的代码中`*ptr`和`*(ptr+2)`的值分别是什么？

    //     1. 12 16
    //     2. 12 14

    // 5. 在下面的代码中`**ptr`和`**(ptr+1)`的值分别是什么

    //     1. 12 16
    //     2. 12 14

    // 6. 假设有下面的声明
    //     int grid[30][100];
    //     1. 用1种写法表示grid[22][56];
    //     2. 用2种写法表示grid[22][0];
    //     3. 用3种写法表示grid[0][0];

    //     // 1
    //     // &grid[22][56]
    //     // 2
    //     // &grid[22][0]
    //     // &grid[22]
    //     // 3
    //     // &grid[0][0];
    //     // &grid[0];
    //     // (int *) grid;

    // 7. 正确声明如下变量

    //     1. digits是一个内含10个int类型值的数组 // int digits[10];
    //     2. rates是一个内含6个float类型值的数组// float rates[6];
    //     3. mat是一个内含3个元素的数组每个元素都是内含5个整数的数组// int mat[3][5];
    //     4. psa是一个内含20个元素的数组每个元素都是指向int的指针// int *pas[20];
    //     5. pstr是一个指向数组的指针，该数组内含20个char类型的值//char (*pstr)[20];

    // 8. 
    //     1. 声明一个内含6个int元素的数组，初始化各个元素为 1，2，4，8，16，32 // int arr[6]={1,2,4,8,16,32};
    //     2. 用数组表示法表示a声明的数组的第3个元素(值为4) // a[3];
    //     3. 声明一个内含100个int类型值的数组并初始化最后一个元素为-1// int a[100]={[99]=-1};

    // 9. 内含10个元素的数组的下标是什么
    //     0-9

    // 10. 判断下列各项是否有效

    //     1. y
    //     2. n //rootbeer不是float类型
    //     3. n
    //     4. n
    //     5. y
    //     6. n
    //     7. n //value不是地址
    //     8. y

    // 11. 声明一个800x600的int类型数组

    //     int grid[800][600];

    // 12. 声明下面三个数组

    //     double trots[20];
    //     short clops[10][30];
    //     long shots[5][10][15];

    //     1. 分别以传统方式和以变长数组为参数的方式编写处理trots数组的void函数原型和函数调用。
    //     2. 分别以传统方式和以变长数组为参数的方式编写处理clops数组的void函数原型和函数调用。
    //     3. 分别以传统方式和以变长数组为参数的方式编写处理shots数组的void函数原型和函数调用。

    //     void trots(double a[]);
    //     void trots(int len ,double a[len]);
    //     void clops(short a[][30]);
    //     void clops(int len, int col ,short a[len][col]);
    //     void shots(long a[][10][30]);
    //     void shots(int x,int y,int z,a[x][y][z]);

    // 13. 下面有两个函数原型

    //     void show(const double ar[],int n);
    //     void show2(const double ar2[][3],int n);

    //     1. 编写一个函数调用吧一个内含8,3,9和2的复合字面量传递给show函数
    //         // show((double[3]){8,3,9},3);
    //     2. 编写一个函数调用把一个两行三列的复合字面量（8，3，9作为第一行5，4，2作为第二行）传递给show2函数.
    //         // show2((double[2][3]){{8,3,9},{5,4,2}},2);

```
