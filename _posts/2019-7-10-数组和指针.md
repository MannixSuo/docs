---
title: 数组和指针
layout: posts
tags: C语音
---

数组初始化

```c
int powers[8] = {1,2,4,,6,8,16,32,64};
sizeof(powers); //数组的大小，以字节为单位
sizeof(powers)/sizeof(powers[0]);// 数组内元素的个数
//如果省略方括号中的数字，编译器会根据列表中的项数确定数组大小。
```

未初始化的数组里面的元素是内存相应位置上现有的值。

如果初始化数组内的部分元素剩余的元素就会被初始化为0；

C99新增指定初始化器

```C
int arr[6] = {[5]=212};
// 第5个元素初始化为212 其他的为0
// 如果指定初始化器后面有更多的值，那个后面的值会被用于指定初始化指定元素后面的元素
int stuff[] = {1,[6]=4,9,10};
// 最终会有9个元素0-8
```

C不允许把一个数组赋值给另一个数组。
也不允许花括号形式的赋值。

```c
float rain[5][12];
// 内含5个数组元素的数组，每个数组元素内含有12个float类型的值
short data[10];
short * pti;
pti = data; //把数组地址赋值给指针
pti +1;// 在c语言中指针加一指的是增加一个存储单元，加一后意味着地址是下个元素的地址不是下一个字节的地址。这就是为什么需要声明指针所指向对象类型的原因
pti+2==&data[2];// 相同的地址
*(pti+2)==data[2];//相同的值
```

以数组为参数的函数原型：
int sum(int * ar); or int sum(int ar[]);
只有在函数原型或者函数定义头中才能使用`int ar[]`代替`int *ar`
`int ar[]`只能用于声明形式参数。`(int ar[])` 提醒读者指针ar指向的不仅仅是一个int类型的值，还是int类型的数组的元素

数组名是数组首元素的地址。

指针变量也有自己的地址和值，他的值就是所它所指向的地址。

指针求差求出两个元素之间的距离。

### 千万不要解引用未初始化的指针 ###

为了防止函数修改数组中的值，在形式参数前加const可防止数组的值被函数修改

int sum(const int arr[],int len);

指向const的指针不能用于修改值

```c
double arr[] = {1.1,2.2,3.3,4.4,5.5,6.6};
const double carr[] = {1.1,2.2,3.3,4.4,5.5,6.6};
const double * pt = arr;
double * ptr;
*pt = 6.6; // 不允许 因为pt指针声明为const表明该指针不能用来修改它所指向的值
pt++;// 允许 可以让pt指向别处
ptr = carr;//不允许 const变量不能赋值给非const指针

double * const pc = arr;// 该指针不能指向别处 只能指向初始化时的地址。
const double * const ccpc;//该指针不能指向别处也不能修改其指向的值
```



